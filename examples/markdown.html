<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>dual-scroll-sync — Markdown Example</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { font-family: system-ui, sans-serif; height: 100vh; display: flex; flex-direction: column; background: #1e1e2e; color: #cdd6f4; }
  header { padding: 12px 20px; background: #181825; border-bottom: 1px solid #313244; display: flex; align-items: center; gap: 16px; }
  header h1 { font-size: 16px; font-weight: 600; }
  header span { font-size: 13px; color: #a6adc8; }
  .container { flex: 1; display: flex; overflow: hidden; }
  .pane { flex: 1; display: flex; flex-direction: column; }
  .pane-header { padding: 8px 16px; background: #181825; font-size: 12px; color: #a6adc8; text-transform: uppercase; letter-spacing: 0.5px; border-bottom: 1px solid #313244; }
  #editor { flex: 1; padding: 20px; background: #1e1e2e; color: #cdd6f4; border: none; outline: none; resize: none; font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace; font-size: 14px; line-height: 1.7; overflow-y: auto; }
  .divider { width: 3px; background: #313244; cursor: col-resize; }
  .divider:hover { background: #89b4fa; }
  #preview { flex: 1; padding: 20px 28px; overflow-y: auto; font-size: 15px; line-height: 1.7; }
  #preview h1 { font-size: 28px; margin: 20px 0 12px; color: #cba6f7; }
  #preview h2 { font-size: 22px; margin: 18px 0 10px; color: #89b4fa; border-bottom: 1px solid #313244; padding-bottom: 6px; }
  #preview h3 { font-size: 18px; margin: 14px 0 8px; color: #a6e3a1; }
  #preview p { margin: 10px 0; }
  #preview ul, #preview ol { margin: 10px 0 10px 24px; }
  #preview li { margin: 4px 0; }
  #preview code { background: #313244; padding: 2px 6px; border-radius: 4px; font-size: 13px; }
  #preview pre { background: #181825; padding: 16px; border-radius: 8px; margin: 12px 0; overflow-x: auto; }
  #preview pre code { background: none; padding: 0; }
  #preview blockquote { border-left: 3px solid #89b4fa; padding: 8px 16px; margin: 12px 0; color: #a6adc8; }
  #preview table { border-collapse: collapse; margin: 12px 0; width: 100%; }
  #preview th, #preview td { border: 1px solid #313244; padding: 8px 12px; text-align: left; }
  #preview th { background: #181825; }
  #preview hr { border: none; border-top: 1px solid #313244; margin: 20px 0; }
  #preview img { max-width: 100%; border-radius: 8px; }
</style>
</head>
<body>

<header>
  <h1>dual-scroll-sync</h1>
  <span>Markdown Editor Example — Scroll either pane</span>
</header>

<div class="container">
  <div class="pane">
    <div class="pane-header">Source</div>
    <textarea id="editor" spellcheck="false"></textarea>
  </div>
  <div class="divider"></div>
  <div class="pane">
    <div class="pane-header">Preview</div>
    <div id="preview"></div>
  </div>
</div>

<script type="module">
import { DualScrollSync } from '../src/index.js';

const editor = document.getElementById('editor');
const preview = document.getElementById('preview');

// ─── Minimal Markdown renderer (just enough for demo) ───

function renderMarkdown(src) {
  let html = '';
  let lineNum = 0;
  const lines = src.split('\n');
  let inCode = false;
  let inList = false;
  let listType = '';

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    lineNum = i + 1;

    if (line.startsWith('```')) {
      if (inCode) { html += '</code></pre>'; inCode = false; }
      else { html += `<pre data-line="${lineNum}"><code>`; inCode = true; }
      continue;
    }
    if (inCode) { html += escapeHtml(line) + '\n'; continue; }

    // Close list if needed
    if (inList && !line.match(/^[\s]*[-*\d]/)) {
      html += listType === 'ul' ? '</ul>' : '</ol>';
      inList = false;
    }

    if (line.match(/^#{1,3}\s/)) {
      const level = line.match(/^(#+)/)[1].length;
      const text = line.replace(/^#+\s*/, '');
      html += `<h${level} data-line="${lineNum}">${renderInline(text)}</h${level}>`;
    } else if (line.match(/^>\s/)) {
      html += `<blockquote data-line="${lineNum}">${renderInline(line.replace(/^>\s*/, ''))}</blockquote>`;
    } else if (line.match(/^---+$/)) {
      html += `<hr data-line="${lineNum}">`;
    } else if (line.match(/^\s*[-*]\s/)) {
      if (!inList || listType !== 'ul') {
        if (inList) html += '</ol>';
        html += '<ul>';
        inList = true; listType = 'ul';
      }
      html += `<li data-line="${lineNum}">${renderInline(line.replace(/^\s*[-*]\s/, ''))}</li>`;
    } else if (line.match(/^\s*\d+\.\s/)) {
      if (!inList || listType !== 'ol') {
        if (inList) html += '</ul>';
        html += '<ol>';
        inList = true; listType = 'ol';
      }
      html += `<li data-line="${lineNum}">${renderInline(line.replace(/^\s*\d+\.\s/, ''))}</li>`;
    } else if (line.trim()) {
      html += `<p data-line="${lineNum}">${renderInline(line)}</p>`;
    }
  }
  if (inCode) html += '</code></pre>';
  if (inList) html += listType === 'ul' ? '</ul>' : '</ol>';
  return html;
}

function escapeHtml(s) {
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

function renderInline(s) {
  s = escapeHtml(s);
  s = s.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
  s = s.replace(/\*(.+?)\*/g, '<em>$1</em>');
  s = s.replace(/`(.+?)`/g, '<code>$1</code>');
  return s;
}

// ─── Setup ───

function editorPixelAtLine(line) {
  const cs = getComputedStyle(editor);
  const lh = parseFloat(cs.lineHeight) || 24;
  const pt = parseFloat(cs.paddingTop) || 20;
  return pt + (line - 1) * lh;
}

function updatePreview() {
  preview.innerHTML = renderMarkdown(editor.value);
  sync.invalidate();
}

const sync = new DualScrollSync(editor, preview, {
  getAnchors: () => {
    return Array.from(preview.querySelectorAll('[data-line]')).map(el => {
      const line = parseInt(el.dataset.line);
      return {
        aPx: editorPixelAtLine(line),
        bPx: el.getBoundingClientRect().top - preview.getBoundingClientRect().top + preview.scrollTop,
      };
    });
  },
});

let timer;
editor.addEventListener('input', () => {
  clearTimeout(timer);
  timer = setTimeout(updatePreview, 150);
});

// ─── Sample document ───

editor.value = `# dual-scroll-sync Demo

This is a live demonstration of the virtual-axis scroll sync algorithm.

## How It Works

Both panes derive their scroll positions from a single **virtual axis**. Neither pane is primary — they are fully symmetric. The virtual axis distance for each interval equals the maximum of the two pane distances, so the longer side scrolls at full speed while the shorter side moves proportionally slower.

## Features

- Pixel-based virtual axis (vS = max(aS, bS))
- Immediate scroll application
- Binary search O(log n) lookups
- Dirty-flag map caching
- Expected-value circular event prevention
- Zero framework dependencies

## Code Example

\`\`\`javascript
const sync = new DualScrollSync(editor, preview, {
  getAnchors: () => {
    return headings.map(h => ({
      aPx: h.editorPx,
      bPx: h.previewPx,
      snap: true,
    }));
  }
});

// After content changes:
sync.invalidate();
\`\`\`

## Blank Line Stress Test

The following blank lines exist in the source but produce no height in the preview. The virtual axis handles this naturally — the editor scrolls at full speed while the preview barely moves.
${''.padEnd(0)}
${''.padEnd(0)}
${''.padEnd(0)}
${'\n'.repeat(40)}
## After the Gap

If you can see this section, the scroll sync survived the blank line gap. The editor had a lot of empty space to traverse, but the preview kept moving (slowly) instead of stopping.

## Comparison Table

This table takes more space in the preview than in the source:

- VS Code: O(n) linear scan, no animation, asymmetric
- Joplin: O(n) + IPC overhead, line-percent intermediate
- StackEdit: O(n), one-way sync
- dual-scroll-sync: O(log n), pixel-based virtual axis, fully symmetric

## Long Paragraphs

The core insight is that scroll synchronization is fundamentally a problem of mapping between two different coordinate spaces. Traditional approaches pick one space as primary and derive the other, which introduces asymmetry and edge cases. The virtual axis approach creates a third, unified space that encompasses both, eliminating the asymmetry entirely.

The pixel-based virtual axis ensures that the pane with more content in each segment scrolls at normal speed, while the shorter pane follows proportionally. This eliminates the jarring jumps that ratio-based approaches suffer from when content heights are very different.

Wheel input maps directly to virtual axis pixels. Combined with optional damping near snap anchors and snap-to-heading after scroll stops, this provides a natural, predictable scrolling experience.

## Ordered List

1. Build anchor points from content (pixel positions)
2. Construct virtual axis (vS = max(aS, bS) per segment)
3. Handle wheel events on virtual axis
4. Look up both pane positions from virtual position
5. Set scrollTop on both panes
6. Optional: damping near snap anchors
7. Optional: snap to nearest anchor after scroll stops

## Final Section

If you scrolled here from the top, everything is working. Try scrolling with the mousewheel, trackpad, or scrollbar to compare the feel.

---

*Built with dual-scroll-sync — MIT License*
`;

updatePreview();
</script>
</body>
</html>
