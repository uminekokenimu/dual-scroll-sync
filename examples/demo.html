<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>dual-scroll-sync v0.6.0</title>
    <style>
      :root {
        --bg: #1a1a2e;
        --surface: #16213e;
        --surface2: #0f3460;
        --accent: #e94560;
        --accent2: #f59e0b;
        --text: #e0e0e0;
        --text-dim: #8892a4;
        --border: #2a3a5c;
        --gutter-bg: #0d1b36;
        --fm: "Consolas", "Monaco", "Courier New", monospace;
        --fs: Georgia, "Source Serif 4", serif;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: var(--bg);
        color: var(--text);
        font-family: var(--fm);
        height: 100vh;
        display: flex;
        flex-direction: column;
        overflow: hidden;
      }

      header {
        padding: 10px 20px;
        background: var(--surface);
        border-bottom: 1px solid var(--border);
        display: flex;
        align-items: center;
        gap: 14px;
        flex-shrink: 0;
      }

      header h1 {
        font-size: 13px;
        font-weight: 600;
        color: var(--accent);
      }

      header .badge {
        font-size: 9px;
        background: var(--accent);
        color: #fff;
        padding: 2px 7px;
        border-radius: 3px;
        font-weight: 600;
      }

      header .info {
        margin-left: auto;
        font-size: 10px;
        color: var(--text-dim);
      }

      header .info span {
        color: var(--accent2);
        font-weight: 600;
      }

      .main {
        flex: 1;
        display: flex;
        overflow: hidden;
      }

      .pw {
        flex: 1;
        display: flex;
        position: relative;
        min-width: 0;
      }

      .pw + .pw {
        border-left: 1px solid var(--border);
      }

      .pl {
        position: absolute;
        top: 6px;
        left: 10px;
        font-size: 9px;
        text-transform: uppercase;
        letter-spacing: 1.5px;
        color: var(--text-dim);
        z-index: 5;
        pointer-events: none;
      }

      .pane {
        flex: 1;
        overflow-y: auto;
        padding: 28px 18px 80px;
        scroll-behavior: auto;
        min-width: 0;
      }

      .pane::-webkit-scrollbar {
        width: 5px;
      }

      .pane::-webkit-scrollbar-track {
        background: transparent;
      }

      .pane::-webkit-scrollbar-thumb {
        background: var(--border);
        border-radius: 3px;
      }

      #ind {
        width: 12px;
        flex-shrink: 0;
        background: var(--gutter-bg);
        border-left: 1px solid var(--border);
        border-right: 1px solid var(--border);
        position: relative;
        cursor: pointer;
        user-select: none;
      }

      .im {
        position: absolute;
        left: 2px;
        right: 2px;
        height: 2px;
        background: var(--accent2);
        border-radius: 1px;
        pointer-events: none;
      }

      .ic {
        position: absolute;
        left: 1px;
        right: 1px;
        height: 3px;
        background: var(--accent);
        border-radius: 2px;
        pointer-events: none;
        box-shadow: 0 0 6px var(--accent);
      }

      #ed {
        font-family: var(--fm);
        font-size: 12.5px;
        line-height: 1.65;
        white-space: pre-wrap;
        word-wrap: break-word;
        outline: none;
        color: var(--text);
        caret-color: var(--accent);
        tab-size: 2;
      }

      #pv {
        font-family: var(--fs);
        font-size: 15px;
        line-height: 1.75;
      }

      #pv h1,
      #pv h2,
      #pv h3 {
        font-family: var(--fs);
        color: var(--accent2);
        margin: 1.4em 0 0.4em;
        line-height: 1.3;
      }

      #pv h1 {
        font-size: 26px;
        border-bottom: 2px solid var(--accent);
        padding-bottom: 6px;
      }

      #pv h2 {
        font-size: 21px;
      }

      #pv h3 {
        font-size: 17px;
      }

      #pv p {
        margin: 0.7em 0;
      }

      #pv ul,
      #pv ol {
        margin: 0.7em 0 0.7em 1.4em;
      }

      #pv li {
        margin: 0.2em 0;
      }

      #pv code {
        font-family: var(--fm);
        font-size: 11.5px;
        background: var(--surface2);
        padding: 2px 5px;
        border-radius: 3px;
      }

      #pv pre {
        background: var(--surface);
        border: 1px solid var(--border);
        border-radius: 5px;
        padding: 12px;
        margin: 0.8em 0;
        overflow-x: auto;
      }

      #pv pre code {
        background: none;
        padding: 0;
        font-size: 11.5px;
        line-height: 1.55;
      }

      #pv blockquote {
        border-left: 3px solid var(--accent);
        padding-left: 12px;
        color: var(--text-dim);
        margin: 0.8em 0;
        font-style: italic;
      }

      #pv strong {
        color: #fff;
      }

      #pv em {
        color: var(--text-dim);
      }

      #pv hr {
        border: none;
        border-top: 1px solid var(--border);
        margin: 1.8em 0;
      }

      #pv table {
        border-collapse: collapse;
        margin: 0.8em 0;
        width: 100%;
      }

      #pv th,
      #pv td {
        padding: 6px 12px;
        border: 1px solid var(--border);
        text-align: left;
        font-size: 13px;
      }

      #pv th {
        background: var(--surface2);
        color: var(--accent2);
        font-weight: 600;
      }

      footer {
        padding: 6px 20px;
        background: var(--surface);
        border-top: 1px solid var(--border);
        font-size: 10px;
        color: var(--text-dim);
        display: flex;
        gap: 20px;
        flex-shrink: 0;
      }

      footer .v {
        color: var(--accent2);
        font-weight: 600;
      }
    </style>
  </head>

  <body>
    <header>
      <h1>dual-scroll-sync</h1>
      <span class="badge">v0.6.0</span>
      <div class="info">
        Anchors: <span id="sa">-</span> | vTotal: <span id="sv">-</span>px
      </div>
    </header>
    <div class="main">
      <div class="pw">
        <span class="pl">Editor</span>
        <div id="ep" class="pane">
          <div id="ed" contenteditable="true" spellcheck="false"></div>
        </div>
      </div>
      <div id="ind">
        <div class="ic" id="ic"></div>
      </div>
      <div class="pw">
        <span class="pl">Preview</span>
        <div id="pp" class="pane">
          <div id="pv"></div>
        </div>
      </div>
    </div>
    <footer>
      <div>A: <span class="v" id="fa">0</span>px</div>
      <div>B: <span class="v" id="fb">0</span>px</div>
      <div>V: <span class="v" id="fv">0</span>px</div>
    </footer>
    <script>
      // @@LIB-START@@
    /**
     * dual-scroll-sync v0.6.0
     *
     * Synchronized scrolling for two panes with different content heights.
     *
     * Each segment's virtual length is `vS = max(aS, bS)` — the pane with
     * more content scrolls at normal speed; the other follows proportionally.
     * Wheel input moves along the virtual axis in pixels: one notch moves
     * the dominant pane exactly `deltaY` pixels, like normal browser scrolling.
     *
     * @module dual-scroll-sync
     * @version 0.6.0
     * @license MIT
     */

    // ─── Pump threshold ───

    /** Remaining wheel delta below this value (px) ends the pump loop. */
    const PUMP_STOP_PX = 5;

    /** Threshold (px) for absorbing programmatic scroll echoes. */
    const ECHO_GUARD_PX = 2;

    // ─── Core ───

    /**
     * Build a virtual-axis scroll map from anchors.
     *
     * @param {import('./index.d.ts').Anchor[]} anchors
     * @param {number} sMaxA - scrollHeight − clientHeight of pane A.
     * @param {number} sMaxB - scrollHeight − clientHeight of pane B.
     * @returns {import('./index.d.ts').MapData}
     */
    function buildMap(anchors, sMaxA, sMaxB) {
      const sorted = anchors
        .map((e) => ({
          aPx: Math.max(0, Math.min(sMaxA, Math.round(e.aPx))),
          bPx: Math.max(0, Math.min(sMaxB, Math.round(e.bPx))),
        }))
        .sort((x, y) => x.aPx - y.aPx);

      const pts = [{ aPx: 0, bPx: 0 }];
      let lastB = 0;
      let droppedCount = 0;
      for (let i = 0; i < sorted.length; i++) {
        const e = sorted[i];
        if (e.bPx >= lastB && e.aPx > pts[pts.length - 1].aPx) {
          pts.push(e);
          lastB = e.bPx;
        } else {
          droppedCount++;
        }
      }
      pts.push({ aPx: sMaxA, bPx: sMaxB });

      let vCum = 0;
      const map = [];
      for (let i = 0; i < pts.length - 1; i++) {
        const aS = pts[i + 1].aPx - pts[i].aPx;
        const bS = pts[i + 1].bPx - pts[i].bPx;
        const vS = Math.max(aS, bS);
        map.push({
          aPx: pts[i].aPx,
          bPx: pts[i].bPx,
          vPx: vCum,
          aS,
          bS,
          vS,
        });
        vCum += vS;
      }

      return {
        segments: map,
        vTotal: vCum,
        droppedCount,
      };
    }

    /**
     * Look up a position on one axis given a position on another.
     * Binary search + linear interpolation within the segment.
     *
     * @param {import('./index.d.ts').Segment[]} segments
     * @param {"aPx"|"bPx"|"vPx"} from - Source axis.
     * @param {"aPx"|"bPx"|"vPx"} to   - Target axis.
     * @param {number} value  - Position on source axis (px). Caller must clamp
     *   to valid range; out-of-range values are extrapolated, not clamped.
     * @returns {number} Position on target axis (px).
     */
    function lookup(segments, from, to, value) {
      if (segments.length === 0) return 0;

      const fromS = from.charAt(0) + "S";
      const toS = to.charAt(0) + "S";

      let lo = 0,
        hi = segments.length - 1;
      while (lo < hi) {
        const mid = (lo + hi + 1) >> 1;
        if (segments[mid][from] <= value) lo = mid;
        else hi = mid - 1;
      }

      const seg = segments[lo];
      if (seg[fromS] <= 0) return seg[to];
      const t = (value - seg[from]) / seg[fromS];
      return seg[to] + t * seg[toS];
    }

    // ─── Controller ───

    /**
     * Synchronized scrolling controller for two scrollable elements.
     *
     * @example
     * const sync = new DualScrollSync(editor, preview, {
     *   getAnchors: () => headingAnchors(),
     *   wheel: { smooth: 0.08, brake: { factor: 0.2, zone: 100 } },
     * });
     */
    class DualScrollSync {
      /**
       * @param {import('./index.d.ts').ScrollPane} paneA
       * @param {import('./index.d.ts').ScrollPane} paneB
       * @param {import('./index.d.ts').SyncOptions} opts
       */
      constructor(paneA, paneB, opts) {
        this.paneA = paneA;
        this.paneB = paneB;
        this.getAnchors = opts.getAnchors;
        this.onSync = opts.onSync || null;
        this.onMapBuilt = opts.onMapBuilt || null;
        this.enabled = true;

        const w = opts.wheel ?? {};
        this.wheel = {
          smooth: w.smooth ?? 0.1,
          brake: w.brake ? { factor: w.brake.factor, zone: w.brake.zone } : null,
        };

        const g = typeof globalThis !== "undefined" ? globalThis : {};
        const raf = g.requestAnimationFrame;
        const caf = g.cancelAnimationFrame;
        this._requestFrame =
          opts.requestFrame || (raf ? raf.bind(g) : (fn) => setTimeout(fn, 16));
        this._cancelFrame = opts.cancelFrame || (caf ? caf.bind(g) : clearTimeout);

        this._data = null;
        this._dirty = true;
        this._vCurrent = 0;
        this._expectedA = null;
        this._expectedB = null;
        this._wheelRemaining = 0;
        this._pumpRafId = null;
        this._applying = false;

        this._onScrollA = () => {
          this._handleScroll("a");
        };
        this._onScrollB = () => {
          this._handleScroll("b");
        };
        this._onWheel = (e) => {
          this._onWheelEvent(e);
        };

        paneA.addEventListener("scroll", this._onScrollA);
        paneB.addEventListener("scroll", this._onScrollB);
        paneA.addEventListener("wheel", this._onWheel, { passive: false });
        paneB.addEventListener("wheel", this._onWheel, { passive: false });
      }

      /** Mark the scroll map for rebuild on next access. */
      invalidate() {
        this._dirty = true;
      }

      /**
       * Ensure the scroll map is current.
       * @returns {import('./index.d.ts').MapData}
       */
      ensureMap() {
        if (this._dirty || !this._data) {
          const sA = Math.max(0, this.paneA.scrollHeight - this.paneA.clientHeight);
          const sB = Math.max(0, this.paneB.scrollHeight - this.paneB.clientHeight);
          try {
            this._data = buildMap(this.getAnchors(), sA, sB);
          } catch {
            this._data = { segments: [], vTotal: 0, droppedCount: 0 };
          }
          this._dirty = false;
          if (this.onMapBuilt) this.onMapBuilt(this._data);
        }
        return this._data;
      }

      /** Remove all event listeners and timers. */
      destroy() {
        this.enabled = false;
        this._wheelRemaining = 0;
        if (this._pumpRafId !== null) {
          this._cancelFrame(this._pumpRafId);
          this._pumpRafId = null;
        }
        this.paneA.removeEventListener("scroll", this._onScrollA);
        this.paneB.removeEventListener("scroll", this._onScrollB);
        this.paneA.removeEventListener("wheel", this._onWheel);
        this.paneB.removeEventListener("wheel", this._onWheel);
      }

      /** @private Set both panes from _vCurrent. */
      _applyV() {
        this._applying = true;
        const segs = this._data.segments;
        this.paneA.scrollTop = lookup(segs, "vPx", "aPx", this._vCurrent);
        this.paneB.scrollTop = lookup(segs, "vPx", "bPx", this._vCurrent);
        this._expectedA = this.paneA.scrollTop;
        this._expectedB = this.paneB.scrollTop;
        this._applying = false;
        if (this.onSync) this.onSync();
      }

      /** @private Handle native scroll event; absorb echoes and sync the opposite pane. */
      _handleScroll(source) {
        if (!this.enabled || this._applying) return;

        if (source === "a" && this._expectedA !== null) {
          if (Math.abs(this.paneA.scrollTop - this._expectedA) < ECHO_GUARD_PX) {
            this._expectedA = null;
            return;
          }
          this._expectedA = null;
        }
        if (source === "b" && this._expectedB !== null) {
          if (Math.abs(this.paneB.scrollTop - this._expectedB) < ECHO_GUARD_PX) {
            this._expectedB = null;
            return;
          }
          this._expectedB = null;
        }

        const segs = this.ensureMap().segments;
        if (segs.length === 0) return;

        if (source === "a") {
          this._vCurrent = lookup(segs, "aPx", "vPx", this.paneA.scrollTop);
          this.paneB.scrollTop = lookup(segs, "vPx", "bPx", this._vCurrent);
          this._expectedB = this.paneB.scrollTop;
        } else {
          this._vCurrent = lookup(segs, "bPx", "vPx", this.paneB.scrollTop);
          this.paneA.scrollTop = lookup(segs, "vPx", "aPx", this._vCurrent);
          this._expectedA = this.paneA.scrollTop;
        }
        if (this.onSync) this.onSync();
      }

      /** @private Validate wheel event, preventDefault, and dispatch delta. */
      _onWheelEvent(e) {
        if (!this.enabled || e.shiftKey || e.ctrlKey || e.metaKey) return;
        if (e.deltaX !== 0 && e.deltaY === 0) return;
        if (this.wheel.smooth <= 0) return;
        e.preventDefault();
        let dy = e.deltaY;
        if (e.deltaMode === 1) dy *= 16;
        else if (e.deltaMode === 2) dy *= this.paneA.clientHeight;
        if (this.wheel.smooth >= 1) {
          this._handleWheel(dy);
          return;
        }
        this._wheelRemaining += dy;
        if (this._pumpRafId === null) this._pumpWheel();
      }

      /** @private Compute anchor-proximity damping factor. */
      _anchorDamping() {
        const brake = this.wheel.brake;
        if (!brake || brake.factor >= 1 || brake.zone <= 0) return 1;
        const { segments } = this.ensureMap();
        const v = this._vCurrent;
        let minDist = Infinity;
        for (let i = 0; i < segments.length; i++) {
          minDist = Math.min(minDist, Math.abs(v - segments[i].vPx));
        }
        const t = Math.min(minDist / brake.zone, 1);
        const s = t * t * (3 - 2 * t);
        return brake.factor + (1 - brake.factor) * s;
      }

      /** @private Drain _wheelRemaining across rAF frames. */
      _pumpWheel() {
        this._pumpRafId = this._requestFrame(() => {
          if (!this.enabled) {
            this._pumpRafId = null;
            return;
          }
          const drain = this._wheelRemaining * this.wheel.smooth;
          const delta = drain * this._anchorDamping();
          this._wheelRemaining -= drain;
          this._handleWheel(delta);
          if (Math.abs(this._wheelRemaining) >= PUMP_STOP_PX) this._pumpWheel();
          else this._pumpRafId = null;
        });
      }

      /** @private Apply delta to vCurrent, sync panes. */
      _handleWheel(delta) {
        const d = this.ensureMap();
        this._vCurrent = Math.max(0, Math.min(d.vTotal, this._vCurrent + delta));
        this._applyV();
      }
    }


    // @@LIB-END@@

      // === Markdown Parser ===

      function parseMd(src) {
        const blocks = [];
        let html = src.replace(
          /```(\w*)\n([\s\S]*?)```/g,
          function (_, lang, code) {
            const i = blocks.length;
            blocks.push(
              "<pre data-block><code>" + esc(code.trim()) + "</code></pre>",
            );
            return "\x00B" + i + "\x00";
          },
        );
        html = esc(html);
        html = html.replace(/^### (.+)$/gm, "<h3 data-heading>$1</h3>");
        html = html.replace(/^## (.+)$/gm, "<h2 data-heading>$1</h2>");
        html = html.replace(/^# (.+)$/gm, "<h1 data-heading>$1</h1>");
        html = html.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
        html = html.replace(/\*(.+?)\*/g, "<em>$1</em>");
        html = html.replace(/`([^`]+)`/g, "<code>$1</code>");
        html = html.replace(/^---$/gm, "<hr data-block>");
        html = html.replace(
          /^&gt; (.+)$/gm,
          "<blockquote data-block>$1</blockquote>",
        );
        html = html.replace(
          /^(\|.+\|)\n(\|[\s\-:|]+\|)\n((?:\|.+\|\n?)+)/gm,
          function (m, hdr, sep, body) {
            const hs = hdr.split("|").filter(function (c) {
              return c.trim();
            });
            const rs = body
              .trim()
              .split("\n")
              .map(function (r) {
                return r.split("|").filter(function (c) {
                  return c.trim();
                });
              });
            let o =
              "<table data-block><thead><tr>" +
              hs
                .map(function (h) {
                  return "<th>" + h.trim() + "</th>";
                })
                .join("") +
              "</tr></thead><tbody>";
            rs.forEach(function (r) {
              o +=
                "<tr>" +
                r
                  .map(function (c) {
                    return "<td>" + c.trim() + "</td>";
                  })
                  .join("") +
                "</tr>";
            });
            return o + "</tbody></table>";
          },
        );
        html = html.replace(/^- (.+)$/gm, "<li>$1</li>");
        html = html.replace(
          /(<li>[\s\S]*?<\/li>(\s*<li>[\s\S]*?<\/li>)*)/g,
          "<ul data-block>$1</ul>",
        );
        html = html
          .split("\n")
          .map(function (l) {
            const t = l.trim();
            if (!t || /^</.test(t) || t.indexOf("\x00B") === 0) return t;
            return "<p data-block>" + t + "</p>";
          })
          .join("\n");
        html = html.replace(/\x00B(\d+)\x00/g, function (_, i) {
          return blocks[+i];
        });
        return html;
      }
      function esc(s) {
        return s
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
      }

      // === Anchor computation (px-based) ===

      function getAnchors(edPane, pvPane, edEl, pvEl) {
        const text = edEl.textContent;
        const lines = text.split("\n");
        const headings = pvEl.querySelectorAll("[data-heading]");

        const edRect = edPane.getBoundingClientRect();
        const pvRect = pvPane.getBoundingClientRect();

        // TreeWalker for editor char → Y
        const walker = document.createTreeWalker(edEl, NodeFilter.SHOW_TEXT);
        const nmap = [];
        let nd,
          off = 0;
        while ((nd = walker.nextNode())) {
          nmap.push({ n: nd, s: off, e: off + nd.length });
          off += nd.length;
        }

        function charY(cp) {
          for (let i = 0; i < nmap.length; i++) {
            if (cp >= nmap[i].s && cp < nmap[i].e) {
              const r = document.createRange();
              const lo = cp - nmap[i].s;
              r.setStart(nmap[i].n, lo);
              r.setEnd(nmap[i].n, Math.min(lo + 1, nmap[i].n.length));
              return (
                r.getBoundingClientRect().top - edRect.top + edPane.scrollTop
              );
            }
          }
          return edPane.scrollHeight;
        }

        function elemY(el) {
          return el.getBoundingClientRect().top - pvRect.top + pvPane.scrollTop;
        }

        const anchors = [];

        // Heading anchors (skip lines inside fenced code blocks)
        let hIdx = 0;
        let cp = 0;
        let inFence = false;
        for (let i = 0; i < lines.length; i++) {
          if (/^```/.test(lines[i])) {
            inFence = !inFence;
          } else if (
            !inFence &&
            /^#{1,3}\s/.test(lines[i]) &&
            hIdx < headings.length
          ) {
            anchors.push({
              aPx: Math.round(charY(cp)),
              bPx: Math.round(elemY(headings[hIdx])),
            });
            hIdx++;
          }
          cp += lines[i].length + 1;
        }

        // Block-level anchors (table, pre) for density in sparse regions
        const blocks = pvEl.querySelectorAll(
          "table[data-block], pre[data-block]",
        );
        for (let j = 0; j < blocks.length; j++) {
          const block = blocks[j];
          const bTop = Math.round(elemY(block));
          const bBot = Math.round(elemY(block) + block.offsetHeight);

          // Find editor position by matching content
          const snippet = block.textContent.substring(0, 40).trim();
          if (!snippet) continue;
          let idx = text.indexOf(snippet);
          if (idx < 0) continue;

          // Back up to block start
          if (block.tagName === "TABLE") {
            while (idx > 0 && text[idx - 1] !== "\n") idx--;
          } else if (block.tagName === "PRE") {
            const fence = text.lastIndexOf("```", idx);
            if (fence >= 0 && idx - fence < 200) idx = fence;
          }

          const aTop = Math.round(charY(idx));

          // Estimate editor bottom: find end of contiguous block source
          let endIdx = idx;
          if (block.tagName === "TABLE") {
            let nl = idx;
            while (nl < text.length) {
              const next = text.indexOf("\n", nl + 1);
              if (next < 0) {
                nl = text.length;
                break;
              }
              const nextLine = text.substring(nl + 1, next).trim();
              if (!nextLine.startsWith("|")) {
                nl = next;
                break;
              }
              nl = next;
            }
            endIdx = nl;
          } else if (block.tagName === "PRE") {
            const close = text.indexOf("```", idx + 3);
            endIdx = close >= 0 ? close + 3 : idx + 100;
          }
          const aBot = Math.round(charY(Math.min(text.length - 1, endIdx)));

          anchors.push({ aPx: aTop, bPx: bTop });
          if (bBot - bTop > 50) {
            anchors.push({ aPx: aBot, bPx: bBot });
          }
        }

        return anchors;
      }

      // === Sample MD ===

      const SAMPLE = [
        "# System Architecture Document",
        "",
        "This document describes a distributed data processing platform. It includes large tables, ASCII diagrams, code blocks, and dense content to stress-test scroll synchronization.",
        "",
        "## 1. System Overview",
        "",
        "The platform consists of five subsystems: ingestion, processing, storage, query, and monitoring. Each runs as an independent service cluster.",
        "",
        "Data flows from external sources through ingestion, gets transformed in processing, persisted in storage, and made available through the query layer.",
        "",
        "### 1.1 Component Diagram",
        "",
        "```",
        "+-------------------+     +--------------------+     +------------------+",
        "|                   |     |                    |     |                  |",
        "|   Data Sources    +---->+   Ingestion Layer  +---->+  Message Queue   |",
        "|                   |     |                    |     |                  |",
        "| - REST APIs       |     | - Rate limiting    |     | - Partitioned    |",
        "| - Webhooks        |     | - Schema validate  |     | - Replicated     |",
        "| - File uploads    |     | - Deduplication    |     | - Ordered        |",
        "| - Stream feeds    |     | - Format normalize |     | - Persistent     |",
        "|                   |     |                    |     |                  |",
        "+-------------------+     +--------------------+     +--------+---------+",
        "                                                              |",
        "                                                              v",
        "+-------------------+     +--------------------+     +--------+---------+",
        "|                   |     |                    |     |                  |",
        "|   Query Engine    +<----+   Storage Layer    +<----+  Processing     |",
        "|                   |     |                    |     |                  |",
        "| - SQL interface   |     | - Time-series DB   |     | - Stream proc   |",
        "| - GraphQL API     |     | - Document store   |     | - Batch proc    |",
        "| - Caching layer   |     | - Object storage   |     | - ML pipeline   |",
        "| - Access control  |     | - Search index     |     | - Aggregation   |",
        "|                   |     |                    |     |                  |",
        "+-------------------+     +--------------------+     +------------------+",
        "```",
        "",
        "### 1.2 Technology Stack",
        "",
        "| Layer | Technology | Version | Purpose | Scaling Model | SLA |",
        "|-------|-----------|---------|---------|--------------|-----|",
        "| Ingestion | Go microservices | 1.21 | HTTP/gRPC endpoints with validation and rate limiting per API key | Horizontal auto-scale 3-50 instances based on request rate | 99.99% uptime p99 < 50ms |",
        "| Queue | Apache Kafka | 3.6 | Durable message transport with exactly-once semantics and partition-level ordering guarantees | Fixed partition count with consumer group rebalancing on failure | Zero message loss, < 100ms e2e |",
        "| Processing | Apache Flink | 1.18 | Stream processing with event-time windows, watermarks, and exactly-once state snapshots | Task-level parallelism with automatic checkpoint recovery and rescaling | Lag < 5s at 1M events/sec |",
        "| Storage | PostgreSQL + S3 | 16.1 | Hot data in PG with auto-partitioning, cold data in S3 Parquet with lifecycle policies | Vertical for PG, horizontal for S3, read replicas for analytics | RPO < 1min, RTO < 5min |",
        "| Query | Trino | 433 | Federated SQL across PG, S3, and ES with cost-based optimizer and predicate pushdown | Worker auto-scale on queue depth, spot instances for batch workloads | p95 < 10s for dashboards |",
        "| Search | Elasticsearch | 8.11 | Full-text search, log analytics, metric aggregation with cross-cluster replication | Index-level sharding with automatic rebalancing across data nodes | p99 < 200ms, index lag < 30s |",
        "| Cache | Redis Cluster | 7.2 | Query caching, session storage, rate counters with hash-slot sharding and sentinel HA | Auto-failover < 10s, LRU eviction with configurable maxmemory policies | Hit ratio > 85% |",
        "| Monitor | Prometheus | 2.48 | Metrics collection, alerting rules, long-term storage via Thanos sidecar and compactor | Federation across clusters with hierarchical recording rules | Scrape 15s, alert eval 30s |",
        "",
        "## 2. Data Processing Pipeline",
        "",
        "The processing layer transforms raw events into enriched, aggregated data products.",
        "",
        "### 2.1 Stream Processing Flow",
        "",
        "```",
        "Kafka: raw-events",
        "    |",
        "    v",
        "[Deserialize] --> [Validate] --> [Enrich]",
        "                                    |",
        "                    +---------------+---------------+",
        "                    |               |               |",
        "                    v               v               v",
        "             [1-min window]  [5-min window]  [Session window]",
        "                    |               |               |",
        "                    v               v               v",
        "             [Sink: PG]      [Sink: ES]      [Sink: S3]",
        "```",
        "",
        "### 2.2 Enrichment Rules",
        "",
        "| Rule | Input | Lookup Source | Output | Cache TTL | Fallback |",
        "|------|-------|-------------|--------|-----------|----------|",
        "| Geo-IP | source_ip | MaxMind GeoIP2 database updated weekly with city-level accuracy and confidence scoring for 99.8% of IPv4 and 95% of IPv6 addresses | geo_country, geo_city, geo_lat, geo_lon, geo_accuracy | 24h in Redis keyed by /24 subnet, bulk refresh on DB update | Last known location or unknown with low confidence |",
        "| User Agent | ua_string | Custom pattern library with 15,000 rules covering browsers, bots, mobile apps, IoT devices, and embedded webviews across all major platforms | device_type, browser, browser_ver, os, os_ver, is_bot, is_crawler | 1h keyed by MD5(ua_string), ~2M unique entries in steady state | Basic regex parse, mark unrecognized |",
        "| Company | email_domain | Clearbit API + local PG cache of 2M+ company records with industry classification, employee count ranges, revenue estimates, and tech stack | company_name, industry, size_range, revenue_range, tech_stack[] | 30d in PG, API fallback on miss with exponential backoff and circuit breaker | Skip enrichment, mark unresolved |",
        "| Threat | source_ip, url | AbuseIPDB + VirusTotal + internal blocklist aggregated from 12 threat intelligence feeds with daily reconciliation and deduplication | threat_score 0-100, categories[], is_malicious, first_seen, report_count | 6h for IP, 24h for URL, with background refresh for high-threat entries | Neutral score 50, flag for review |",
        "| Revenue | user_id | Internal billing system with real-time subscription status, historical MRR, expansion/contraction tracking, and churn risk scoring | plan_tier, mrr_cents, lifetime_value, churn_risk, last_activity | 5min for active users, 1h for inactive, invalidated on billing events | Lookup from daily snapshot table |",
        "",
        "## 3. Database Schema",
        "",
        "### 3.1 Events Table (Hot Storage)",
        "",
        "```sql",
        "CREATE TABLE events (",
        "    id              BIGINT GENERATED ALWAYS AS IDENTITY,",
        "    event_id        UUID NOT NULL DEFAULT gen_random_uuid(),",
        "    received_at     TIMESTAMPTZ NOT NULL DEFAULT now(),",
        "    event_type      TEXT NOT NULL,",
        "    source          TEXT NOT NULL,",
        "    payload         JSONB NOT NULL,",
        "    geo_country     TEXT,",
        "    geo_city        TEXT,",
        "    device_type     TEXT,",
        "    threat_score    SMALLINT DEFAULT 0,",
        "    PRIMARY KEY (id, received_at)",
        ") PARTITION BY RANGE (received_at);",
        "CREATE INDEX idx_events_type ON events (event_type, received_at);",
        "CREATE INDEX idx_events_source ON events (source, received_at);",
        "```",
        "",
        "### 3.2 Data Lifecycle",
        "",
        "| Age | Storage | Format | Compression | Access Pattern | Retention Policy |",
        "|-----|---------|--------|------------|---------------|-----------------|",
        "| 0-7d | PostgreSQL NVMe SSD, 3-node HA with sync replication and daily PITR backups to S3 | Row-based with TOAST for JSONB, daily partitions | LZ4 for TOAST columns, zstd for WAL | Point lookups < 1ms, range scans < 50ms | Always hot, 4h backup cycle |",
        "| 7-90d | S3 Standard with cross-region replication, versioning, and integrity checksums | Apache Parquet with Snappy compression, partitioned by date/type/source | Snappy block compression ~3:1, dictionary encoding for strings | Trino federated queries, typical latency 5-30s | On-demand via Trino |",
        "| 90d-1y | S3 Infrequent Access with lifecycle transition, integrity audit monthly | Parquet with zstd compression, yearly partitions merged from daily files | Zstandard level 3 ~5:1 ratio | Quarterly compliance reports, incident investigation | Available within 12h |",
        "| 1y+ | Glacier Deep Archive with vault lock for immutability, cross-account backup | ORC format with maximum compression, yearly archives | Zstandard level 19 ~15:1 for event data | Annual audit and regulatory compliance | 48h retrieval |",
        "",
        "## 4. Monitoring Dashboard",
        "",
        "```",
        "+================================================================+",
        "|  PLATFORM HEALTH                     2024-01-15 14:30 UTC      |",
        "+================================================================+",
        "|  Ingestion    [================----]  847K/min  (85% capacity) |",
        "|  Proc. Lag    [==------------------]  2.1 sec   (OK)           |",
        "|  Queue        [====----------------]  1.2M msgs (20% depth)    |",
        "|  Storage      [============--------]  14.2 TB   (60% used)     |",
        "|  Query p95    [======--------------]  3.2 sec   (within SLA)   |",
        "|  Errors       [=-------------------]  0.02%     (nominal)      |",
        "|  Cache Hit    [=================---]  89%       (target: 85%)  |",
        "+================================================================+",
        "```",
        "",
        "### 4.1 Alert Configuration",
        "",
        "| Alert | Condition | Severity | Action |",
        "|-------|----------|----------|--------|",
        "| Error spike | error_rate > 1% sustained for 5 minutes across all ingestion pods | Critical / PagerDuty | Auto-scale ingestion +50%, page on-call |",
        "| Processing lag | flink_watermark_lag > 30s on any operator in the main pipeline | Warning / Slack | Increase parallelism, trigger savepoint |",
        "| Disk pressure | pg_data_usage > 80% on any node including WAL and temp files | Warning / Slack | Emergency partition cleanup, alert DBA |",
        "| Replication lag | pg_replication_lag > 10s on any replica measured by WAL LSN delta | Critical / PagerDuty | Pause read traffic to lagging replica |",
        "",
        "## 5. Infrastructure Layout",
        "",
        "```",
        "Region: us-east-1",
        "|",
        "+-- AZ-a",
        "|   +-- k8s-node-01 (m5.4xl) : ingestion x4, processing x2",
        "|   +-- k8s-node-02 (m5.4xl) : ingestion x4, query x2",
        "|   +-- pg-primary  (r6g.2xl) : PostgreSQL primary (sync)",
        "|   +-- redis-01    (r6g.xl)  : slots 0-5460",
        "|   +-- kafka-01    (m5.2xl)  : broker 1, partitions 0-99",
        "|",
        "+-- AZ-b",
        "|   +-- k8s-node-03 (m5.4xl) : ingestion x4, processing x2",
        "|   +-- k8s-node-04 (m5.4xl) : query x4",
        "|   +-- pg-replica-1 (r6g.2xl) : sync replica",
        "|   +-- redis-02    (r6g.xl)  : slots 5461-10922",
        "|   +-- kafka-02    (m5.2xl)  : broker 2",
        "|",
        "+-- AZ-c",
        "    +-- k8s-node-05 (m5.4xl) : processing x4, monitoring",
        "    +-- pg-replica-2 (r6g.2xl) : async replica (analytics)",
        "    +-- redis-03    (r6g.xl)  : slots 10923-16383",
        "    +-- kafka-03    (m5.2xl)  : broker 3",
        "```",
        "",
        "## 6. Cost and Recovery",
        "",
        "| Category | Monthly | % | Notes |",
        "|----------|---------|---|-------|",
        "| Compute (EC2) | $18,500 | 37% | 60% reserved, 30% on-demand, 10% spot |",
        "| Storage (S3+EBS) | $12,300 | 25% | S3 lifecycle saves 60% on warm/cold |",
        "| Database (RDS) | $8,200 | 16% | Multi-AZ PG with provisioned IOPS |",
        "| Network | $4,100 | 8% | Cross-AZ replication dominates |",
        "| Managed | $3,800 | 8% | ES, monitoring, DNS, ALB |",
        "| Other | $3,100 | 6% | Backups, CI/CD, dev envs |",
        "| **Total** | **$50,000** | **100%** | **$0.60 per 1M events** |",
        "",
        "- **RPO**: < 1 min (PG sync), < 5 min (S3 cross-region), < 30s (Kafka MirrorMaker2)",
        "- **RTO**: < 15 min including DNS propagation and health verification",
        "",
        "---",
        "",
        "*Edit this document to test scroll sync. Add headings, tables, code blocks. Anchors rebuild automatically.*",
      ].join("\n");

      // === DOM ===

      const ep = document.getElementById("ep");
      const pp = document.getElementById("pp");
      const edEl = document.getElementById("ed");
      const pvEl = document.getElementById("pv");
      const ind = document.getElementById("ind");
      const ic = document.getElementById("ic");

      edEl.textContent = SAMPLE;
      function render() {
        pvEl.innerHTML = parseMd(edEl.textContent);
      }
      render();

      // Wait for layout
      setTimeout(function () {
        let markers = [];
        let dragging = false;

        function updateInd(d) {
          markers.forEach(function (m) {
            m.remove();
          });
          markers = [];
          const m = d.segments,
            vt = d.vTotal;
          for (let i = 0; i < m.length; i++) {
            const el = document.createElement("div");
            el.className = "im";
            el.style.top = (vt > 0 ? (m[i].vPx / vt) * 100 : 0) + "%";
            ind.appendChild(el);
            markers.push(el);
          }
          document.getElementById("sa").textContent = m.length;
          document.getElementById("sv").textContent = Math.round(vt);
        }

        const sync = new DualScrollSync(ep, pp, {
          getAnchors: function () {
            return getAnchors(ep, pp, edEl, pvEl);
          },
          wheel: { smooth: 0.1, brake: { factor: 0.2, zone: 80 } },
          onMapBuilt: function (d) {
            updateInd(d);
          },
          onSync: function () {
            document.getElementById("fa").textContent = Math.round(
              ep.scrollTop,
            );
            document.getElementById("fb").textContent = Math.round(
              pp.scrollTop,
            );
            document.getElementById("fv").textContent = Math.round(
              sync._vCurrent,
            );
            const vt = sync._data ? sync._data.vTotal : 1;
            ic.style.top = (vt > 0 ? (sync._vCurrent / vt) * 100 : 0) + "%";
          },
        });
        sync.ensureMap();

        // Indicator click/drag
        function indClick(e) {
          const r = ind.getBoundingClientRect();
          const f = Math.max(0, Math.min(1, (e.clientY - r.top) / r.height));
          const d = sync.ensureMap();
          const v = f * d.vTotal;
          sync._vCurrent = v;
          ep.scrollTop = lookup(d.segments, "vPx", "aPx", v);
          pp.scrollTop = lookup(d.segments, "vPx", "bPx", v);
          sync._expectedA = ep.scrollTop;
          sync._expectedB = pp.scrollTop;
          if (sync.onSync) sync.onSync();
        }
        ind.addEventListener("mousedown", function (e) {
          if (e.button === 0) {
            e.preventDefault();
            dragging = true;
            indClick(e);
          }
        });
        document.addEventListener("mousemove", function (e) {
          if (dragging) {
            e.preventDefault();
            indClick(e);
          }
        });
        document.addEventListener("mouseup", function () {
          dragging = false;
        });

        // Edit → rebuild
        let timer;
        edEl.addEventListener("input", function () {
          clearTimeout(timer);
          timer = setTimeout(function () {
            render();
            setTimeout(function () {
              sync.invalidate();
              sync.ensureMap();
            }, 300);
          }, 500);
        });
        window.addEventListener("resize", function () {
          sync.invalidate();
          sync.ensureMap();
        });
      }, 300);
    </script>
  </body>
</html>
